=====================
 Теорема об индексах
=====================

.. admonition:: Теорема
   :class: theorem

   Если элементы некоторого множества :math:`A` зависят от конечного
   количества индексов, каждый из которых пробегает счётное множество
   значений, то это множество :math:`A` счётное.

Т. е.:

.. math::

   A=\{a| a=a(x_1, x_2, …, x_n), n \in \mathbb{N}\} \backsim \mathbb{N},

где:

.. math::

   x_1 \in X_1 \backsim \mathbb{N},
   
   x_2 \in X_2 \backsim \mathbb{N},
   
   \ldots,
   
   x_n \in X_n \backsim \mathbb{N}

Здесь говорится о том, что каждый элемент множества :math:`A`
*однозначно* определяется набором своих индексов. Действительно, если
бы какому-нибудь элементу множества :math:`A` соответствовало более
одного набора индексов, то :math:`A` было бы мультимножеством,
т.е. содержало бы этот элемент для каждого из соответствующих ему
наборов индексов. Если бы это было так, то ничто не помешало бы нам
построить множество, состоящее из одинаковых элементов, зависящих от
индексов, например: :math:`A=\{a|a=1^{g(x_1,x_2,…,x_n, …)}\}`, где
:math:`g(x_1,…,x_n, …)` — какая-то функция. Так определённое множество
:math:`A` уже, очевидно, является конечным, т.к. состоит из
единственного элемента :math:`a=1`.

Значит в теореме говорится не о всякой зависимости, а о такой, которая
разным наборам индексов ставит в соответствие разные элементы
множества :math:`A`.

Это, чисто формальное рассуждение, без которого можно было бы и
обойтись [1]_, приводит нас к набору условий (:math:`k \leqslant n`):

1. :math:`\forall a \in A \quad \exists ! \langle x_1,…,x_k \rangle
   \in X_1 \times … \times X_k`,— т.е. для любого элемента множества
   :math:`A` существует единственный набор индексов (который является
   ни чем иным, как элементом декартова произведения множеств, по
   которым "пробегают" индексы). Это означает, что соответствие, в
   силу которого каждому элементу множества :math:`A` соответствует
   набор индексов, является отображением: :math:`f(a): A \rightarrow
   X_1 \times … \times X_k`

2. :math:`\forall \langle x_1, …, x_k \rangle \in X_1 \times … \times
   X_k \quad \exists a \in A`,— любому набору индексов соответствует
   какой-то элемент множества :math:`A`. Это значит, что :math:`f` —
   сюръекция.

3. :math:`\langle x_{1_1}, …, x_{k_1} \rangle \ne \langle x_{1_2}, …,
   x_{k_2} \rangle \Leftrightarrow a(x_{1_1}, …, x_{k_1}) \ne
   a(x_{1_2}, …, x_{k_2})`,— и элементам множества :math:`A`
   соответствуют разные наборы индексов. Поэтому :math:`f` — инъекция.

Эти три условия означают, что :math:`f` — биекция, и поэтому :math:`A
\backsim X_1 \times … \times X_n`

Теперь можно перейти к доказательству.

.. admonition:: Доказательство
   :class: proof

   Проведём методом математической индукции по :math:`n` — количеству
   индексов.

   Дано: :math:`A_n=\{ a_{x_1, x_2, …, x_n}\}`, :math:`x_i \in X_i
   \backsim \mathbb{N}, \{x_i\}_{i=\overline{1,n}}`

   Доказать: :math:`P(n): A_n \backsim \mathbb{N}`

   1. База индукции:
      
      :math:`P(1): A_1=\{a_{x_{1_1}}, a_{x_{1_2}}, …, a_{x_{1_k}}, …\},
      \, x_1 \in X_1=\{x_{1_1}, x_{1_2}, …, x_{1_k}, …\} \backsim
      \mathbb{N}`

      Элементу :math:`a_{x_{1_1}} \in A_1` соответствует набор из одного
      индекса :math:`x_{1_1} \in X_1`

      Элементу :math:`a_{x_{1_2}} \in A_1` соответствует набор из одного
      индекса :math:`x_{1_2} \in X_1`

      …

      Элементу :math:`a_{x_{1_i}} \in A_1` соответствует набор из одного
      индекса :math:`x_{1_i} \in X_1`

      т.е. :math:`\forall a \in A_1 \,\, \exists! x_1 \in X_1`,

      :math:`\forall x_1 \in X_1 \,\, \exists a \in A_1`,

      и для нас все они различны, поэтому:

      :math:`a_{x_{1_i}} \ne a_{x_{1_j}} \Leftrightarrow x_{1_i} \ne
      x_{1_j}`

      Каждому индексу соответствует единственный элемент множества
      :math:`A_1`, и наоборот — каждый элемент множества :math:`A_1`
      определяется единственным индексом :math:`x_{1_i} \in
      X_1`. Значит :math:`A_1 \backsim X_1`. А т.к. :math:`X_1
      \backsim \mathbb{N}`, то по свойству транзитивности отношения
      эквивалентности :math:`A_1 \backsim \mathbb{N}`

      Т.о. :math:`P(1): A_1 \backsim \mathbb{N}`, база индукции
      установлена

   2. Предположим, что выполняется :math:`P(k)`, т.е. :math:`A_k
      \backsim \mathbb{N}`

      Или, подробно: :math:`A_k=\{a_{x_{1_1}, x_{2_1}, x_{3_1}, …,
      x_{k_1}}, a_{x_{1_2},x_{2_2}, …, x_{k_2}}, …, a_{x_{1_m}, …,
      x_{k_m}}, …\} \backsim \mathbb{N}`, где:

      :math:`x_{i_j} \in X_i=\{x_{i_1}, x_{i_2}, …, x_{i_j}, …\}
      \backsim \mathbb{N}`, :math:`i=\overline{1,k}`

.. topic:: Сноски

.. [1] Действительно, ведь в теореме говорится только о том, что
   каждый элемент :math:`A` зависит от :math:`\langle x_1, …, x_n
   \rangle`, и ничего не говорится ни о характере этой зависимости, ни
   о том, каковы сами эти элементы множества :math:`A`. В частности не
   говорится о том одинаковы они или различны. Для нас, однако,
   существенно то, что *для нас они различны* хотя бы потому, что они
   зависят от разных наборов индексов. Т.е. мы отвлекаемся
   (абстрагируемся) от всего, что не касается различности этих
   элементов, связанной с их зависимостью от разных индексов. Нас
   интересует только эта различность. И этого достаточно, чтобы
   сказать: "Элемент :math:`a \in A` однозначно определяется своим
   набором индексов". Т.е. мы можем записать определение множества
   :math:`A` иначе:

   .. math::

      A=\left\{a_{x_1, x_2, …, x_n}\right\}

   где :math:`x_i \in X_i \backsim \mathbb{N}, \{x_i\}_{i=\overline{1,n}}`

